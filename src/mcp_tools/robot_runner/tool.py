#!/usr/bin/env python
"""
MCP Tool: Robot Runner
Executes .robot test cases and returns the results.
"""

import os
import logging
import json
import tempfile
from typing import List, Dict, Any, Optional, Union
from pathlib import Path
from datetime import datetime
from pydantic import BaseModel, Field
from mcp.server.fastmcp import FastMCP

from src.utils.helpers import (
    run_robot_command,
    is_robot_file,
    parse_robot_output_xml
)
from src.config.config import (
    ROBOT_OUTPUT_DIR,
    ROBOT_REPORT_DIR,
    DEFAULT_TIMEOUT
)

logger = logging.getLogger('robot_tool.runner')

# -----------------------------------------------------------------------------
# Request and Response Models
# -----------------------------------------------------------------------------

class RobotRunnerRequest(BaseModel):
    """Request model for robot_runner tool."""
    file_path: str = Field(
        description="Path to a .robot file to run"
    )
    test_names: Optional[List[str]] = Field(
        None,
        description="Names of specific test cases to run"
    )
    include_tags: Optional[List[str]] = Field(
        None,
        description="Tags to include in the test run"
    )
    exclude_tags: Optional[List[str]] = Field(
        None,
        description="Tags to exclude from the test run"
    )
    variables: Optional[Dict[str, str]] = Field(
        None,
        description="Variables to pass to the test run"
    )
    output_dir: Optional[str] = Field(
        None,
        description="Directory to save test outputs"
    )
    timeout: Optional[int] = Field(
        DEFAULT_TIMEOUT,
        description="Timeout for the test run in seconds"
    )

class RobotRunnerResponse(BaseModel):
    """Response model for robot_runner tool."""
    success: bool = Field(
        description="Whether the test run was successful"
    )
    output: Dict[str, Any] = Field(
        default_factory=dict,
        description="Parsed output from the test run"
    )
    logs: Dict[str, str] = Field(
        default_factory=dict,
        description="Paths to log files generated by the test run"
    )
    error: Optional[str] = Field(
        None,
        description="Error message if an error occurred"
    )

# -----------------------------------------------------------------------------
# Tool Implementation
# -----------------------------------------------------------------------------

def run_robot_tests(
    file_path: str,
    test_names: Optional[List[str]] = None,
    include_tags: Optional[List[str]] = None,
    exclude_tags: Optional[List[str]] = None,
    variables: Optional[Dict[str, str]] = None,
    output_dir: Optional[str] = None,
    timeout: int = DEFAULT_TIMEOUT
) -> Dict[str, Any]:
    """
    Run Robot Framework tests and return the results.
    
    Args:
        file_path: Path to a .robot file to run
        test_names: Names of specific test cases to run
        include_tags: Tags to include in the test run
        exclude_tags: Tags to exclude from the test run
        variables: Variables to pass to the test run
        output_dir: Directory to save test outputs
        timeout: Timeout for the test run in seconds
        
    Returns:
        Dictionary with test results and any error
    """
    result = {
        "success": False,
        "output": {},
        "logs": {},
        "error": None
    }
    
    try:
        # Check if file exists and is a Robot Framework file
        file_path_obj = Path(file_path)
        if not file_path_obj.exists():
            return {
                "success": False,
                "output": {},
                "logs": {},
                "error": f"File not found: {file_path}"
            }
        
        if not is_robot_file(file_path_obj):
            return {
                "success": False,
                "output": {},
                "logs": {},
                "error": f"Not a valid Robot Framework file: {file_path}"
            }
        
        # Determine output directory
        if output_dir:
            output_path = Path(output_dir)
        else:
            output_path = Path(ROBOT_OUTPUT_DIR)
        
        # Create output directory if it doesn't exist
        os.makedirs(output_path, exist_ok=True)
        
        # Generate unique names for output files
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        output_xml = output_path / f"output_{timestamp}.xml"
        log_html = output_path / f"log_{timestamp}.html"
        report_html = output_path / f"report_{timestamp}.html"
        
        # Build command
        cmd = ["robot"]
        
        # Add test names
        if test_names:
            for test_name in test_names:
                cmd.extend(["--test", test_name])
        
        # Add tags
        if include_tags:
            for tag in include_tags:
                cmd.extend(["--include", tag])
                
        if exclude_tags:
            for tag in exclude_tags:
                cmd.extend(["--exclude", tag])
        
        # Add variables
        if variables:
            for name, value in variables.items():
                cmd.extend(["--variable", f"{name}:{value}"])
        
        # Add output files
        cmd.extend([
            "--outputdir", str(output_path),
            "--output", str(output_xml.name),
            "--log", str(log_html.name),
            "--report", str(report_html.name)
        ])
        
        # Add file to run
        cmd.append(str(file_path_obj))
        
        # Run the command
        logger.info(f"Running Robot Framework tests: {' '.join(cmd)}")
        success, stdout, stderr = run_robot_command(cmd, timeout=timeout)
        
        result["logs"] = {
            "output_xml": str(output_xml),
            "log_html": str(log_html),
            "report_html": str(report_html),
            "stdout": stdout,
            "stderr": stderr
        }
        
        # Parse output.xml if it was generated
        if output_xml.exists():
            result["output"] = parse_robot_output_xml(output_xml)
            
        result["success"] = success
        
        if not success:
            result["error"] = f"Robot Framework test execution failed: {stderr}"
            
        logger.info(f"Test execution completed with success={success}")
        return result
        
    except Exception as e:
        logger.error(f"Error running Robot Framework tests: {e}")
        return {
            "success": False,
            "output": result["output"],
            "logs": result["logs"],
            "error": f"Error running Robot Framework tests: {str(e)}"
        }

# -----------------------------------------------------------------------------
# MCP Tool Registration
# -----------------------------------------------------------------------------

def register_tool(mcp: FastMCP):
    """Register the robot_runner tool with the MCP server."""
    
    @mcp.tool()
    async def robot_runner(
        file_path: str,
        test_names: Optional[List[str]] = None,
        include_tags: Optional[List[str]] = None,
        exclude_tags: Optional[List[str]] = None,
        variables: Optional[Dict[str, str]] = None,
        output_dir: Optional[str] = None,
        timeout: Optional[int] = DEFAULT_TIMEOUT
    ) -> Dict[str, Any]:
        """
        Run Robot Framework tests and return the results.
        
        Args:
            file_path: Path to a .robot file to run
            test_names: Names of specific test cases to run
            include_tags: Tags to include in the test run
            exclude_tags: Tags to exclude from the test run
            variables: Variables to pass to the test run
            output_dir: Directory to save test outputs
            timeout: Timeout for the test run in seconds
            
        Returns:
            Dictionary with test results and any error
        """
        logger.info(f"Running Robot tests for file: {file_path}")
        
        # Pass all parameters directly to the implementation function
        result = run_robot_tests(
            file_path=file_path,
            test_names=test_names,
            include_tags=include_tags,
            exclude_tags=exclude_tags,
            variables=variables,
            output_dir=output_dir,
            timeout=timeout if timeout is not None else DEFAULT_TIMEOUT
        )
        
        return result 